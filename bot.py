import logging
import asyncio
from aiogram import Bot, Dispatcher, types
from aiogram.types import ParseMode, ReplyKeyboardMarkup, KeyboardButton
from aiogram.utils import executor
import os
import json
from datetime import datetime
from apscheduler.schedulers.asyncio import AsyncIOScheduler
import aiohttp
import tempfile
from aiogram.types import InputFile

API_TOKEN = os.getenv("BOT_TOKEN")
ADMIN_ID = 490364050

logging.basicConfig(level=logging.INFO)
bot = Bot(token=API_TOKEN)
dp = Dispatcher(bot)

POSTS_FILE = "posts.txt"

def load_posts():
    try:
        with open(POSTS_FILE, "r", encoding="utf-8") as f:
            posts = f.read().split("---")
            return [p.strip() for p in posts if p.strip()]
    except:
        return []

def save_posts(posts):
    with open(POSTS_FILE, "w", encoding="utf-8") as f:
        f.write("\n---\n".join(posts))

# –ö–ª–∞–≤–∏–∞—Ç—É—Ä–∞ –º–µ–Ω—é
main_kb = ReplyKeyboardMarkup(resize_keyboard=True)
main_kb.add(
    KeyboardButton("üìã –°–ø–∏—Å–æ–∫ –ø–æ—Å—Ç–æ–≤"),
    KeyboardButton("üÜï –î–æ–±–∞–≤–∏—Ç—å –ø–æ—Å—Ç")
).add(
    KeyboardButton("üóë –£–¥–∞–ª–∏—Ç—å –ø–æ—Å—Ç"),
    KeyboardButton("‚úèÔ∏è –†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å –ø–æ—Å—Ç")
).add(
    KeyboardButton("‚è∞ –ó–∞–ø–ª–∞–Ω–∏—Ä–æ–≤–∞—Ç—å –ø–æ—Å—Ç"),
    KeyboardButton("üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞")
)

SCHEDULED_POSTS_FILE = "scheduled_posts.json"
scheduler = AsyncIOScheduler()

def load_scheduled_posts():
    try:
        with open(SCHEDULED_POSTS_FILE, "r", encoding="utf-8") as f:
            return json.load(f)
    except:
        return []

def save_scheduled_posts(posts):
    with open(SCHEDULED_POSTS_FILE, "w", encoding="utf-8") as f:
        json.dump(posts, f, ensure_ascii=False, indent=2)

async def check_scheduled_posts():
    now = datetime.now().strftime("%Y-%m-%d %H:%M")
    posts = load_scheduled_posts()
    remaining = []

    for post in posts:
        if post["datetime"] == now:
            try:
                if post["type"] == "text":
                    await bot.send_message(CHANNEL_ID, post["text"], parse_mode=ParseMode.MARKDOWN)

                elif post["type"] == "photo":
                    await bot.send_photo(CHANNEL_ID, post["file_id"], caption=post.get("caption", ""), parse_mode=ParseMode.MARKDOWN)

                elif post["type"] == "album":
                    media = []
                    for m in post["media"]:
                        item = InputMediaPhoto(media=m["media"], caption=m.get("caption", ""))
                        media.append(item)
                    await bot.send_media_group(CHANNEL_ID, media)
                elif post["type"] == "photo_file":
                    photo = InputFile(post["path"])
                    await bot.send_photo(CHANNEL_ID, photo, caption=post.get("caption", ""), parse_mode=ParseMode.MARKDOWN)

            except Exception as e:
                print(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ –ø–æ—Å—Ç–∞: {e}")
        else:
            remaining.append(post)

    save_scheduled_posts(remaining)

# === –ü–æ–¥–¥–µ—Ä–∂–∫–∞ —Å—Å—ã–ª–æ–∫ –Ω–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è ===
async def download_image_from_url(url):
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(url) as resp:
                if resp.status == 200:
                    with tempfile.NamedTemporaryFile(delete=False) as tmp_file:
                        tmp_file.write(await resp.read())
                        return tmp_file.name
    except Exception as e:
        print(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è: {e}")
        return None

@dp.message_handler(commands=["start"])
async def start(message: types.Message):
    if message.from_user.id != ADMIN_ID:
        return await message.answer("‚õî –î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â—ë–Ω.")
    await message.answer("–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ –ø–∞–Ω–µ–ª—å —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –±–æ—Ç–æ–º!", reply_markup=main_kb)

@dp.message_handler(lambda msg: msg.text == "üìã –°–ø–∏—Å–æ–∫ –ø–æ—Å—Ç–æ–≤")
async def list_posts(message: types.Message):
    posts = load_posts()
    if not posts:
        return await message.answer("‚ùå –ü–æ—Å—Ç–æ–≤ –ø–æ–∫–∞ –Ω–µ—Ç.")
    text = ""
    for i, p in enumerate(posts):
        preview = p.replace('\n', ' ')[:100]
        text += "{}. {}...\n\n".format(i + 1, preview)
    await message.answer("üìã –°–ø–∏—Å–æ–∫ –ø–æ—Å—Ç–æ–≤:\n\n{}".format(text))

@dp.message_handler(lambda msg: msg.text == "üÜï –î–æ–±–∞–≤–∏—Ç—å –ø–æ—Å—Ç")
async def add_post_prompt(message: types.Message):
    await message.answer("‚úèÔ∏è –í–≤–µ–¥–∏—Ç–µ –Ω–æ–≤—ã–π –ø–æ—Å—Ç. –ö–∞–∫ –∑–∞–∫–æ–Ω—á–∏—Ç–µ ‚Äî –æ—Ç–ø—Ä–∞–≤—å—Ç–µ –µ–≥–æ –≤ –æ–¥–Ω–æ–º —Å–æ–æ–±—â–µ–Ω–∏–∏.")

    @dp.message_handler()
    async def receive_new_post(msg: types.Message):
        if msg.from_user.id != ADMIN_ID:
            return
        posts = load_posts()
        posts.append(msg.text.strip())
        save_posts(posts)
        await msg.answer("‚úÖ –ü–æ—Å—Ç –¥–æ–±–∞–≤–ª–µ–Ω!")
        dp.message_handlers.unregister(receive_new_post)

@dp.message_handler(lambda msg: msg.text == "üóë –£–¥–∞–ª–∏—Ç—å –ø–æ—Å—Ç")
async def delete_post_prompt(message: types.Message):
    await message.answer("–í–≤–µ–¥–∏—Ç–µ –Ω–æ–º–µ—Ä –ø–æ—Å—Ç–∞, –∫–æ—Ç–æ—Ä—ã–π —Ö–æ—Ç–∏—Ç–µ —É–¥–∞–ª–∏—Ç—å.")

    @dp.message_handler()
    async def receive_delete_index(msg: types.Message):
        if msg.from_user.id != ADMIN_ID:
            return
        try:
            index = int(msg.text.strip()) - 1
            posts = load_posts()
            if 0 <= index < len(posts):
                deleted = posts.pop(index)
                save_posts(posts)
                await msg.answer("üóë –£–¥–∞–ª—ë–Ω –ø–æ—Å—Ç:\n\n{}...".format(deleted[:100]))
            else:
                await msg.answer("‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π –Ω–æ–º–µ—Ä.")
        except:
            await msg.answer("‚ö†Ô∏è –í–≤–µ–¥–∏—Ç–µ –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π –Ω–æ–º–µ—Ä.")
        dp.message_handlers.unregister(receive_delete_index)

@dp.message_handler(lambda msg: msg.text == "üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞")
async def show_stats(message: types.Message):
    posts = load_posts()
    await message.answer(f"üìä –í—Å–µ–≥–æ –ø–æ—Å—Ç–æ–≤: {len(posts)}")

# === ‚úèÔ∏è –†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –ø–æ—Å—Ç–∞ ===
@dp.message_handler(lambda msg: msg.text == "‚úèÔ∏è –†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å –ø–æ—Å—Ç")
async def edit_post_prompt(message: types.Message):
    await message.answer("–í–≤–µ–¥–∏—Ç–µ –Ω–æ–º–µ—Ä –ø–æ—Å—Ç–∞, –∫–æ—Ç–æ—Ä—ã–π —Ö–æ—Ç–∏—Ç–µ –æ—Ç—Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å.")

    @dp.message_handler()
    async def receive_edit_index(msg: types.Message):
        if msg.from_user.id != ADMIN_ID:
            return
        try:
            index = int(msg.text.strip()) - 1
            posts = load_posts()
            if 0 <= index < len(posts):
                await msg.answer("–í–≤–µ–¥–∏—Ç–µ –Ω–æ–≤—ã–π —Ç–µ–∫—Å—Ç –¥–ª—è –ø–æ—Å—Ç–∞ ‚Ññ{}:".format(index + 1))

                @dp.message_handler()
                async def receive_new_content(new_msg: types.Message):
                    if new_msg.from_user.id != ADMIN_ID:
                        return
                    posts[index] = new_msg.text.strip()
                    save_posts(posts)
                    await new_msg.answer("‚úÖ –ü–æ—Å—Ç ‚Ññ{} –æ–±–Ω–æ–≤–ª—ë–Ω.".format(index + 1))
                    dp.message_handlers.unregister(receive_new_content)

                dp.message_handlers.unregister(receive_edit_index)
            else:
                await msg.answer("‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π –Ω–æ–º–µ—Ä –ø–æ—Å—Ç–∞.")
                dp.message_handlers.unregister(receive_edit_index)
        except:
            await msg.answer("‚ö†Ô∏è –í–≤–µ–¥–∏—Ç–µ –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π –Ω–æ–º–µ—Ä.")
            dp.message_handlers.unregister(receive_edit_index)

from aiogram.types import ContentType, InputMediaPhoto

@dp.message_handler(lambda msg: msg.text == "‚è∞ –ó–∞–ø–ª–∞–Ω–∏—Ä–æ–≤–∞—Ç—å –ø–æ—Å—Ç")
async def schedule_post_prompt(message: types.Message):
    await message.answer("–í–≤–µ–¥–∏—Ç–µ –¥–∞—Ç—É –∏ –≤—Ä–µ–º—è –ø—É–±–ª–∏–∫–∞—Ü–∏–∏ (–≤ —Ñ–æ—Ä–º–∞—Ç–µ –ì–ì–ì–ì-–ú–ú-–î–î –ß–ß:–ú–ú):")

    @dp.message_handler()
    async def receive_datetime(msg: types.Message):
        if msg.from_user.id != ADMIN_ID:
            return
        try:
            scheduled_time = datetime.strptime(msg.text.strip(), "%Y-%m-%d %H:%M")
            await msg.answer("–¢–µ–ø–µ—Ä—å –æ—Ç–ø—Ä–∞–≤—å—Ç–µ –ø–æ—Å—Ç: —ç—Ç–æ –º–æ–∂–µ—Ç –±—ã—Ç—å —Ç–µ–∫—Å—Ç, —Ñ–æ—Ç–æ –∏–ª–∏ –∞–ª—å–±–æ–º –∏–∑ —Ñ–æ—Ç–æ —Å –ø–æ–¥–ø–∏—Å—å—é.")

            album = []

            @dp.message_handler(content_types=ContentType.ANY)
            async def receive_post(msg: types.Message):
                if msg.from_user.id != ADMIN_ID:
                    return

                if msg.content_type == ContentType.TEXT:
                    post = {
                        "datetime": scheduled_time.strftime("%Y-%m-%d %H:%M"),
                        "type": "text",
                        "text": msg.text.strip()
                    }
                elif msg.text.strip().startswith("http"):
                    # –ü–æ–ø—ã—Ç–∫–∞ –∑–∞–≥—Ä—É–∑–∏—Ç—å —Ñ–æ—Ç–æ –ø–æ —Å—Å—ã–ª–∫–µ
                    img_path = await download_image_from_url(msg.text.strip())
                    if img_path:
                         post = {
                            "datetime": scheduled_time.strftime("%Y-%m-%d %H:%M"),
                            "type": "photo_file",
                            "path": img_path,
                            "caption": ""
                        }
                    else:
                        await msg.answer("‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –ø–æ —Å—Å—ã–ª–∫–µ.")
                        return
                elif msg.content_type == ContentType.PHOTO:
                    post = {
                        "datetime": scheduled_time.strftime("%Y-%m-%d %H:%M"),
                        "type": "photo",
                        "file_id": msg.photo[-1].file_id,
                        "caption": msg.caption or ""
                    }

                elif msg.media_group_id:
                    # –°–æ–±–∏—Ä–∞–µ–º –∞–ª—å–±–æ–º
                    album.append(msg)
                    await asyncio.sleep(1.5)
                    if not album or msg.media_group_id != album[0].media_group_id:
                        return

                    post = {
                        "datetime": scheduled_time.strftime("%Y-%m-%d %H:%M"),
                        "type": "album",
                        "media": [{"type": "photo", "media": m.photo[-1].file_id, "caption": m.caption or ""} for m in album]
                    }

                else:
                    await msg.answer("‚ö†Ô∏è –¢–∏–ø –∫–æ–Ω—Ç–µ–Ω—Ç–∞ –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è.")
                    return

                posts = load_scheduled_posts()
                posts.append(post)
                save_scheduled_posts(posts)

                await msg.answer("‚úÖ –ü–æ—Å—Ç –∑–∞–ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω –Ω–∞ {}.".format(post["datetime"]))
                dp.message_handlers.unregister(receive_post)
                dp.message_handlers.unregister(receive_datetime)

            dp.message_handlers.unregister(receive_datetime)
        except:
            await msg.answer("‚ö†Ô∏è –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç. –ò—Å–ø–æ–ª—å–∑—É–π: 2025-04-10 12:00")
            dp.message_handlers.unregister(receive_datetime)
    
# ===== StubServer –¥–ª—è Render (—á—Ç–æ–±—ã –Ω–µ –ø–∞–¥–∞–ª –∏–∑-–∑–∞ –ø–æ—Ä—Ç–æ–≤) =====
import threading
from http.server import BaseHTTPRequestHandler, HTTPServer

class StubServer(BaseHTTPRequestHandler):
    def do_GET(self):
        self.send_response(200)
        self.end_headers()
        self.wfile.write(b"Bot is alive!")

def run_stub_server():
    server = HTTPServer(("0.0.0.0", 10000), StubServer)
    server.serve_forever()

threading.Thread(target=run_stub_server, daemon=True).start()

# ===== –ó–∞–ø—É—Å–∫ –ø–ª–∞–Ω–∏—Ä–æ–≤—â–∏–∫–∞ –ø—Ä–∏ —Å—Ç–∞—Ä—Ç–µ =====
async def on_startup(_):
    scheduler.add_job(check_scheduled_posts, "interval", minutes=1)
    scheduler.start()

# ===== –ó–∞–ø—É—Å–∫ –±–æ—Ç–∞ =====
if __name__ == "__main__":
    executor.start_polling(dp, on_startup=on_startup)
